---
layout:       post
title:        "가비지  수집  기초"
author:       "yunki kim"
header-style: text
catalog:      true
tags:
- java
- ComputerScience
- 도서
- 자바 최적화
---

자바 가비지 수집의 요체는 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하며 쓸모없는 객체를 알아서 제거하는 것이다.
모든 가비지 수집 구현체는 다음과 같은 원칙을 지켜야 한다.
- 알고리즘은 반드시 모든 가비지를 수집해야 한다.
- 살아 있는 객체는 절대로 수집해선 안된다.
  - segmentation fault 방지

# mark and sweep
자바의 가비지 수집은 기본적으로 mark and sweep이라는 알고리즘을 사용한다. 가장 단순한 mark and sweep 알고리즘의 경우 아직 회수되지 않은 객체를 가리키는 포인토를 포함하는 allocated list를 사용한다. 전체적인 알고리즘은 다음과 같다.
- 할당 리스트를 순회하면서 마크 비트를 지운다
- GC 루트부터 살아 있는 객체를 찾는다
  - DFS를 사용한다.
  - 이렇게 해서 생성된 그래프를 라이브 객체 그래프라고 한다.
- 찾은 객체마다 마크 비트를 세팅한다
- allocated list를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾는다
  - 힙에서 메모리를 회수해 free list에 넣는다
  - allocated list에서 객체를 삭제한다

## 가비지 수집 용어
GC 알고리즘을 이해하기 위해 필요한 용어는 다음과 같다.
- STW(Stop The World)
  - GC 사이클이 발생해 가비지를 수집하는 동안에 모든 애프리케이션 스레드를 중단하는 것
- 동시
  - GC 스레드는 애플리케이션 스레드와 동시 실행될 수 있다. 이는 계산 비용면에서 비싸고 어려운 작업이다. 또 한, 100% 동시 실행을 보장하는 알고리즘도 없다.
- 병렬
  - 여러 스레드를 동원해서 가비지 수집을 한다
- 정확
  - 정확한 GC 스킴은 전체 가비지를 한번에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 가지고 있다.
- 보수
  - 보수적인 스킴은 정확한 스킴의 정보가 없다. 때문에 리소스를 자주 낭비하고 타입 체계를 무시한다.
- 이동
  - 이동 수집기에서 객체는의 메모리 주소는 고정적이지 않다. 때문에 C++처럼 raw pointer로 직접 접근할 수 있는 환경과 잘 맞지 않는다.
- 압착
  - 살아남은 객체들은 GC 사이클 마지막에 연속된 단일 영역으로 배열된다. 그리고 객체 쓰기가 가능한 여백의 시작점을 가리키는 포인터가 존재한다. 압착 수집기는 메모리 단편화를 방지한다.
- 방출
  - 수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 방출한다.

# 핫스팟 런타임 개요
## 객체를 런타임에 표현하는 방법
핫스팟은 런타임에 oop(Ordinary Object Pointer)라는 구조체로 객체를 나타낸다. 
Oop class의 필드 부분은 각 다음과 같은 정보를 가진다.
```java
// Oop represents the superclass for all types of
// objects in the HotSpot object heap.

public class Oop {
  static {
    VM.registerVMInitializedObserver(new Observer() {
        public void update(Observable o, Object data) {
          initialize(VM.getVM().getTypeDataBase());
        }
      });
  }

  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
    Type type  = db.lookupType("oopDesc");
    mark       = new CIntField(type.getCIntegerField("_mark"), 0);
    klass      = new MetadataField(type.getAddressField("_metadata._klass"), 0);
    compressedKlass  = new NarrowKlassField(type.getAddressField("_metadata._compressed_klass"), 0);
    headerSize = type.getSize();
  }

  /**
   * 사용하는 주소가 "특별"하며 VM에 의해 업데이트 된다는 것을 나타낸다.
   * 현재 VM에서 리플렉션 구현을 위해 사용된다.
  */
  private OopHandle  handle;

  /**
   * VM에 존재하는 모든 generation을 추상화한 타입
   * 존재하는 모든 객체와 클래스에 접근할 수 있다.
   * JVM이 객체를 할당하고 관리하는 힙 영역을 나타낸다.
   * 객체가 메모리에 할당되고 반환될때 사용된다.
  */
  private ObjectHeap heap;

  Oop(OopHandle handle, ObjectHeap heap) {
    this.handle = handle;
    this.heap   = heap;
  }

  private static long headerSize;
  private static CIntField mark; // GC에서 사용되는 마킹 정보
  private static MetadataField  klass; // 클래스에 대한 정보를 저장한다
  /**
   * NarrowKlassFiel는 MetadataField를 extends하고 있다.
   * JVM 메모리 효율을 높이기 위해 클래스에 대한 포인터를 압축해 저장한다.
  */
  private static NarrowKlassField compressedKlass;
```
oop는 자바 메서드의 스택 프레임으로부터 자바 힙을 구형하는 메모리 내부를 카르킨다.
hotspot은 내부적으로 Oop를 이용해 여러 자료구조를 정의한다. 그 중 Instance는 자바 클래스의 인스턴스를 나타낸다.
```java
// An Instance is an instance of a Java Class

public class Instance extends Oop {
  static {
    VM.registerVMInitializedObserver(new Observer() {
        public void update(Observable o, Object data) {
          initialize(VM.getVM().getTypeDataBase());
        }
      });
  }
  private static long typeSize;

  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
    Type type = db.lookupType("instanceOopDesc");
    typeSize = type.getSize();
  }

  Instance(OopHandle handle, ObjectHeap heap) {
    super(handle, heap);
  }

  ...
}
```
instanceOop의 메모리 레이아웃은 기계어 워드 2개로 구성된 헤더로 시작한다. Mark 워드(인스턴스 관련 메타데이터를 가리키는 포인터) 다음에 Klass 워드(클래스 메타데이터를 가리키는 포인터)가 나온다.
자바 7까지는 instanceOop의 Klass 워드가 자바 힙에 있는 PemGen이라는 메모리 영역을 가리켰다. 자바 힙에 있는 것들은 객체 헤더를 가져야 하기 때문에 KlassOop로 메타데이터를 참조했다. 그러나 자바8 부터 Klass(클래스에 관련된 정보를 저장하는 클래스. JVM 내부에서 클래스 메타데이터와 관련된 정보를 저장하고 클래스의 동작과 상호작용을 지원한다)가 자바 힙의 주 영역 밖으로 빠졌기 때문에 Klass 워드가 자바 힙 밖을 가리킨다. 때문에 객체 헤더가 필요 없다.